1.Object 클래스에 대하여 설명하시오.

자바에서 모든 클래스는 사실 Object를 암시적으로 상속받고 있다. 따라서 Object는 모든 클래스가 상속하는 최고의 부모 클래스이다.  그 이유는 모든 클래스가 공통으로 포함하고 있어야 하는 기능을 제공하기 위해서다.

 


2.아래와 같이 출력되는 이유를 하시오.

class A {
	
	 @Override
	 public String toString() {
		
		 return "이것은 A 클래스 입니다.";
	 }	
}
 
public class TestMain {
	public static void main(String[] args) {
		A a  = new A();
		System.out.println(a);
		
	   }		
}
===============
이것은 A 클래스 입니다.
toString 없이 출력하게 되면 System.out.println(a); 는 @2768234 출력값이 이렇게 주소로 나온다. (이렇게 나오도록 println을 만들어놨기 때문에)
 

 

3. class 이름 및 함수 에서 final 의 의미는?

클래스 이름에서의 final의 의미는 = 상속이 안된다는 의미. 상속하지 마라.

메소드앞에 final이 왔을때 의미 : 오버라이딩이 안된다. 

 

 

6. interface 와 class 의 차이는

클래스는 크게 일반 클래스와 추상 클래스로 나뉘는데 추상 클래스는 클래스 내 '추상 메소드'가 하나 이상 포함되거나 abstract로 정의된 경우를 말합니다.

반면 인터페이스는 모든 메소드가 추상 메소드인 경우입니다.

 


7. 다음을 프로그램 하시오.[필수]

interface Printable { // MS가 정의하고 제공한 인터페이스
   public void print(String doc);
}
 SPrinterDriver 와 LPrinterDriver를 만드시오
======================
 
public static void main(String[] args) {
   String myDoc = "This is a report about...";
   
   // 삼성 프린터로 출력
   Printable prn = new SPrinterDriver();
   prn.print(myDoc);
   System.out.println();
 
   // LG 프린터로 출력
   prn = new LPrinterDriver();
   prn.print(myDoc);
}
================================================
출력: From Samsung printer
This is a report about ...
 
From LG printer
This is a report about ...
==================================
package java_1214_prac;
 
public class aaaaMain {
	public static void main(String[] args) {
		String myDoc = "This is a report about...";
 
		// 삼성 프린터로 출력
		Printable prn = new SPrinterDriver();
		prn.print(myDoc);
		System.out.println();
 
		// LG 프린터로 출력
		prn = new LPrinterDriver();
		prn.print(myDoc);
	}
 
}
 
package java_1214_prac;
 
interface Printable { // MS가 정의하고 제공한 인터페이스
	public void print(String doc);
 
}
 
class SPrinterDriver implements Printable {
	@Override
	public void print(String doc) {
		System.out.println("From Samsung printer");
		System.out.println(doc);
	}
 
}
 
class LPrinterDriver implements Printable {
	@Override
	public void print(String doc) {
		System.out.println("From LG printer");
		System.out.println(doc);
	}
 
}
 

 

8.@Override 에 대하여 설명하시오.

@Override 을 위에 써주게 되면 오버라이딩아니면 오류내라고 알려주는 역할이다.

오버라이딩 - 똑같은 함수와 변수를 쓰는것.

오버로딩 - 같은 함수명에 변수나 타입이 다른 것.


9.interface 에 대하여 설명하시오.

<인터페이스 특징>

abstract가 붙는다. (=추상 메소드가 온다.)

몸체가 없어서 객체생성이 불가하다. (Printable p = new Printable(); → X )

but, 함수 선언은 가능하다. Printable p;

 

----블로그 설명----

Java에서 abstract, final과 함께 대표적인 규제이며 Java가 추상화를 위해 제공하는 가장 유용한 도구이다.

어떤 클래스가 있고 그 클래스가 특정한 인터페이스를 사용한다면 그 클래스는 반드시 사용한 인터페이스의 메소드들을 구현해야 한다.(=오버라이딩)

만약 인터페이스에서 강제하고 있는 메소드들을 구현하지 않으면 컴파일 조차 되지 않는다.

 

interface 규칙

- 인터페이스에 정의되는 멤버들의 접근제어자는 public이다.

- 하나의 클래스는 복수개의 인터페이스를 구현할 수 있다.

- 인터페이스 상속이 가능하다.

- 인터페이스는 어떤 일을 하겠다는 기능만 정의해 놓는다. 인터페이스에는 어떻게 하겠다는 구현 방법은 나타나 있지 않다. 그것은 인터페이스를 구현한 클래스들이 알아서 결정할 일이다.

----------------------


10.interface에 올수 있는 두가지는?

함수선언() 과 상수(변수x)


11.abstract 키워드에 대하여 설명하시오.

abstract는 자손이 구현하라.

 

추상화 키워드이다.

<인터페이스 특징>

abstract가 붙는다. (=추상 메소드가 온다.)

(abstract 는? = 자손이 구현하라.)

몸체가 없어서 객체생성이 불가하다. (Printable p = new Printable(); )

but, 함수 선언은 가능하다. Printable p;

 

// 이게 생략"public abstract" void printLine(String str); 
// 인터페이스에서는 무조건"public abstract"이거 앞에 넣어줘야함 
// 구현부분없으면 abstract붙어야하는데 컴파일러가 알아서 넣어줌 
void printLine(String str); // =추상메소드

 

12. 아래의 출력 결과가 아래와 같이 나오도록 프로그래밍 하시오.

Object obj = new Circle(10);
System.out.println(obj);
=================
출력: 넓이는 100 입니다.
package java_1214_prac;
 
public class bbbMain {
	public static void main(String[] args) {
		Object obj = new Circle(10.0);
		System.out.println(obj);
	}
 
}
//출력: 넓이는 100 입니다.
package java_1214_prac;
 
interface Object {
 
	public String toString();
 
}
 
class Circle implements Object {
	private double r;
 
	
	public Circle(double r) {
		
	}
 
 
	@Override
	public String toString() {
		return "넓이는 " + (r * r * Math.PI) + "입니다.";
 
	}
 
}
 

13. 아래의 메모리를 그리시오.

class MobilePhone {
    protected String number;
    
    public MobilePhone(String num) {
        number = num;
    }    
    public void answer() {
        System.out.println("Hi~ from " + number);
    }
}
 
class SmartPhone extends MobilePhone { 
    private String androidVer;
    
    public SmartPhone(String num, String ver) {
        super(num);
        androidVer = ver;
    }    
    public void playApp() {
        System.out.println("App is running in " + androidVer);
    }
}
=======================================
	MobilePhone phone = new SmartPhone("010-555-777", "Nougat");
    	phone.answer();    	
    	SmartPhone s = (SmartPhone)phone;    	
    	s.playApp();

